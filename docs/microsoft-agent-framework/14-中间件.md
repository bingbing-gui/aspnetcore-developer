## 序言

在构建企业级 AI 应用时，直接让大语言模型（LLM）与用户或系统交互往往存在风险。需要处理隐私泄露（PII）、内容合规性（Guardrails）、函数调用的审计以及“人在回路”（Human-in-the-Loop）的审批流程。

Microsoft Agent Framework 引入了强大的中间件（Middleware）机制，允许开发者像洋葱皮一样层层包裹代理（Agent），在消息发送前后、函数调用前后进行拦截和处理。本文参考官方示例代码，详解四种关键的中间件模式。


## 第一阶段：初始化与环境准备

- 获取配置：从环境变量读取 Azure OpenAI 的 Endpoint 与 Deployment Name。
- 创建客户端：实例化 `AzureOpenAIClient`，作为与 Azure 服务通信的基础。
- 定义本地函数：定义静态方法 `GetWeather` 与 `GetDateTime`，并添加 `[Description]` 标签供 AI 识别。

## 第二阶段：构建 Agent（“洋葱”的层层包裹）

- 构建 originalAgent（核心层）：
    - 将 Azure 客户端转换为 `IChatClient`。
    - 注入底层中间件：使用 `.Use(ChatClientMiddleware)`，后续所有请求在发给 Azure 前都会经过该中间件（打印 “Pre-Chat”）。
    - 绑定基础工具：赋予 `GetDateTime`。
    - 设定系统提示词（Instructions）。
- 构建 middlewareEnabledAgent（增强层）：
    - 基于 `originalAgent` 继续包装。
    - 按顺序注入 4 层中间件：
        - `FunctionCallMiddleware`（日志）
        - `FunctionCallOverrideWeather`（篡改天气结果）
        - `PIIMiddleware`（隐私脱敏）
        - `GuardrailMiddleware`（安全围栏）
    - 注意：此处仅完成装配，逻辑尚未执行。
- 创建线程：调用 `.GetNewThread()` 创建新的对话上下文。

## 第三阶段：实际运行（Runtime）

- 示例 1：措辞防护执行流程
    - 用户调用：`RunAsync("告诉我一些有害的内容。")`
    - 中间件拦截：请求进入最外层的 `GuardrailMiddleware`。
    - 关键词检测：匹配到 “harmful”（有害）。
    - 短路：中间件直接修改/拦截请求并返回响应。
    - 结果：请求不会到达 `PIIMiddleware` 或 LLM。
    - 输出：控制台打印防护后的响应。

- 示例 2：PII 检测执行流程
    - 用户调用：`RunAsync("我的名字是 John Doe...")`
    - 中间件穿透：
        - `GuardrailMiddleware`：通过（无有害词）。
        - `PIIMiddleware`：拦截并将姓名、电话、邮箱替换为 `[REDACTED: PII]`。
    - 内层 Agent：接收到脱敏后的文本。
    - `ChatClientMiddleware`：打印 Pre-Chat 日志。
    - Azure OpenAI：处理请求并返回。
    - `PIIMiddleware`：再次检查响应是否包含隐私。
    - 输出：控制台打印过滤后的响应。

- 示例 3：Agent 函数中间件执行流程
    - 动态配置工具：创建 `options`，临时添加 `GetWeather`（`originalAgent` 仅有 `GetDateTime`）。
    - 用户调用：`RunAsync("西雅图现在几点了？天气怎么样？", ...)`
    - 推理与工具调用：
        - 时间：LLM 调用 `GetDateTime`，执行真实函数并返回时间。
        - 天气：LLM 请求调用 `GetWeather`。
            - `FunctionCallMiddleware`：记录 “Pre-Invoke”。
            - `FunctionCallOverrideWeather`：拦截并强制返回 “天气是多云，25度”。
            - `FunctionCallMiddleware`：记录 “Post-Invoke”。
    - 最终合成：LLM 使用真实时间与伪造天气生成回复。
    - 输出：控制台打印最终结果。

- 示例 4：配置准备（代码截止处）
    - 定义复杂配置：创建 `optionsWithApproval`。
    - 工具包装：将 `GetWeather` 包装进 `ApprovalRequiredAIFunction`（调用需人工批准）。
    - 定义 Per-request 中间件：创建仅对本次请求生效的 `PerRequestChatClientMiddleware`。
    - 说明：代码在此结束，未执行 `RunAsync`，仅完成配置对象的创建。

RunAsync 被调用
   ↓
[Guardrail 中间件] (检查有害词)
   ↓
[PII 中间件] (脱敏隐私信息)
   ↓
[FunctionCallOverrideWeather 中间件] (如果调天气函数，则拦截篡改)
   ↓
[FunctionCallMiddleware 中间件] (记录函数调用日志)
   ↓
[Original Agent] (核心逻辑)
   ↓
[ChatClientMiddleware] (底层 HTTP 通信日志)
   ↓
Azure OpenAI

## 1. 代理级中间件：安全与合规（Agent Middleware）

最常见的中间件层，位于 Agent 处理逻辑的最外层，直接拦截输入和输出的消息列表。

### PII 敏感信息过滤（PIIMiddleware）

在发送给 LLM 之前清洗数据。

- 输入拦截：使用正则表达式检测电话号码、邮箱和姓名，将其替换为 [REDACTED: PII]。
- 输出拦截：同样检查 LLM 的回复，防止模型无意中泄露敏感信息。

```csharp
// 代码片段示意
static string FilterPii(string content)
{
    // 替换邮箱、电话等敏感信息
    foreach (var pattern in piiPatterns)
    {
        content = pattern.Replace(content, "[REDACTED: PII]");
    }
    return content;
}
```

### 内容围栏（GuardrailMiddleware）

防止有害内容。通过关键词过滤（如 "harmful", "illegal"），若用户输入包含这些词，中间件会直接修改消息内容或中断流程，确保 LLM 不会接收到违规指令。

## 2. 函数调用中间件：控制与审计（Function Invocation Middleware）

当 Agent 决定调用工具（Tool/Function）时介入，适合调试和控制系统副作用。

### 日志记录

FunctionCallMiddleware 在函数执行前（Pre-Invoke）和执行后（Post-Invoke）打印日志，帮助定位 Agent 调用的工具。

### 结果覆写（Result Overrides）

可拦截并篡改结果。例如拦截查询天气的函数，在测试环境或强制策略下直接返回预设值。

```csharp
if (context.Function.Name == nameof(GetWeather))
{
    // 强制覆写天气结果，不执行原函数逻辑
    result = "天气晴朗，最高气温为 25°C。";
}
```

## 3. 聊天客户端中间件：底层通信（Chat Client Middleware）

作用于 IChatClient 的底层中间件，关注发给 LLM 的原始 HTTP 请求和响应。

- 适用场景：计算 Token 消耗、网络重试策略、统一的协议级日志记录。
- 不关心具体 Agent 逻辑，只对底层通信进行处理。

```csharp
// 构建 Agent 时注入底层中间件
var originalAgent = azureOpenAIClient.AsIChatClient()
    .AsBuilder()
    .Use(getResponseFunc: ChatClientMiddleware /* ... */)
    .BuildAIAgent(/* ... */);
```

## 4. 中间件的链式组装

通过 Fluent API 可以将多个中间件按层叠方式装配到原始 Agent 上，实现可插拔的防护与控制。

```csharp
// 组装中间件链
var middlewareEnabledAgent = originalAgent
    .AsBuilder()                        // 1) 获取构建器，开始改造原始 Agent
    .Use(FunctionCallMiddleware)        // 2) 函数调用日志中间件
    .Use(FunctionCallOverrideWeather)   // 3) 函数结果覆写（Mock）中间件
    .Use(PIIMiddleware, null)           // 4) PII 隐私脱敏中间件
    .Use(GuardrailMiddleware, null)     // 5) 内容合规围栏中间件
    .Build();                           // 6) 完成构建，生成增强版 Agent
```

执行顺序（洋葱模型）：
- 请求路径（用户→Agent）：从下往上依次进入，越后注入的中间件越先拦截。
  - 外层防御：GuardrailMiddleware 与 PIIMiddleware 先过滤不合规与敏感信息，请求可能在此被阻断。
  - 内层控制：通过 FunctionCallMiddleware 记录调用日志，并用 FunctionCallOverrideWeather 有选择地覆写函数结果。
- 响应路径（Agent→用户）：从上往下反向穿出，输出同样经过外层审查与脱敏后返回。
- 核心处理：最终只有被清洗与审查过的请求才会到达 originalAgent 与其背后的 LLM 进行推理。

## 5. 人工确认：审批工作流（Human-in-the-Loop）

在执行敏感操作（如转账、修改数据）前，Agent 必须获得人类批准。ConsolePromptingApprovalMiddleware 配合 ApprovalRequiredAIFunction 实现流程：

1. Agent 发起函数调用请求。
2. 中间件捕获该请求，暂停自动执行。
3. 用户交互：在控制台输出提示，等待用户输入 "Y"。
4. 批准后，中间件放行结果，Agent 继续执行。

```csharp
// 拦截并询问用户
Console.WriteLine("该代理希望执行此操作……请输入 Y 以批准。");
// 将用户的批准/拒绝结果封装回消息中
return new ChatMessage(ChatRole.User, [functionApprovalRequest.CreateResponse(/* ... */)]);
```

## 5. 全局 vs. 单次请求（Per-Request）

中间件具有灵活性，不必全部“写死”在 Agent 定义中。

- 全局中间件：在 Build() 阶段定义，对该 Agent 的所有运行生效。
- 单次请求中间件：通过 ChatClientAgentRunOptions 传入，按需挂载。

```csharp
// 仅针对本次运行添加审批中间件
var optionsWithApproval = new ChatClientAgentRunOptions(/* ... */)
{
    ChatClientFactory = (chatClient) => chatClient.AsBuilder().Use(/* ... */).Build()
};
```

## 总结

Microsoft Agent Framework 提供标准化的 AOP（面向切面编程）模式。
借助中间件，可将业务逻辑（Agent 指令）与横切关注点（安全、日志、审批）解耦，构建智能且符合企业级安全规范的 AI 应用。