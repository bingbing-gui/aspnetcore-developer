







# https://www.linkedin.com/in/sandeeppal

## Cross ‑ Cutting / Advanced / “Miscellaneous”

## 134. Hosting: Kestrel, IIS, reverse proxy scenarios

```
● Kestrel is the default cross-platform web server for ASP.NET Core, lightweight and
fast.
```
```
● IIS acts as a reverse proxy on Windows, forwarding requests to Kestrel.
```
```
● Reverse proxies improve security, manage SSL, handle load balancing.
```
```
● On Linux, Nginx or Apache often act as reverse proxies to Kestrel.
```
## 135. InProcess vs OutOfProcess hosting

```
● InProcess hosting runs ASP.NET Core app inside the IIS worker process
(w3wp.exe), better performance.
```
```
● OutOfProcess hosting runs the app in a separate process, IIS proxies requests to
it.
```
```
● InProcess is default in ASP.NET Core 3.0+ for IIS hosting.
```
## 136. Health checks

```
● Health checks provide endpoints to report app health.
```
```
● Use Microsoft.AspNetCore.Diagnostics.HealthChecks.
```
```
● Configure checks for databases, external services, dependencies.
```
```
● Useful for Kubernetes, load balancers.
```

# https://www.linkedin.com/in/sandeeppal

## 137. Logging: built-in logging, third party (Serilog, NLog)

```
● ASP.NET Core has built-in logging with providers (Console, Debug, EventSource).
```
```
● Third-party libs like Serilog and NLog offer rich sinks, structured logging.
```
```
● Configure logging via appsettings.json or code.
```
## 138. Performance tuning: caching (in memory, distributed), response

## compression

```
● In-memory caching stores data on server memory for fast retrieval.
```
```
● Distributed caching uses external stores (Redis, SQL) for multiple servers.
```
```
● Response compression reduces payload size using gzip, Brotli middleware.
```
## 139. Threading concerns, concurrency, deadlocks

```
● Avoid blocking calls in async code to prevent deadlocks.
```
```
● Use async/await properly.
```
```
● Protect shared data with locks or concurrent collections.
```
```
● Avoid thread starvation with thread pool tuning.
```
## 140. Memory leaks, disposal of dependencies

```
● Memory leaks can occur if IDisposable objects aren’t disposed.
```

# https://www.linkedin.com/in/sandeeppal

```
● Use dependency injection lifetimes properly.
```
```
● Be cautious with static references and events holding objects.
```
```
● Use tools like dotMemory, PerfView.
```
## 141. Scalability: load balancing, statelessness

```
● Design apps to be stateless so any server instance can handle requests.
```
```
● Use distributed caches or external session stores.
```
```
● Load balancers distribute traffic to multiple instances.
```
## 142. Deployment: Docker, Azure, CI/CD pipelines

```
● Containerize apps with Docker for consistent deployments.
```
```
● Use Azure App Services, Azure Kubernetes Service for cloud hosting.
```
```
● Set up CI/CD pipelines (GitHub Actions, Azure DevOps) for automated builds and
deployments.
```
## 143. Monitoring, metrics, tracing (OpenTelemetry etc)

```
● Monitor app health, request metrics, errors.
```
```
● Use OpenTelemetry for distributed tracing.
```
```
● Integrate with Application Insights, Prometheus, Grafana.
```

# https://www.linkedin.com/in/sandeeppal

## 144. Security best practices (HTTPS, XSS, CSRF, OWASP)

```
● Enforce HTTPS.
```
```
● Use Anti-forgery tokens to prevent CSRF.
```
```
● Sanitize input to prevent XSS.
```
```
● Follow OWASP guidelines to secure apps.
```
## 145. Middleware for compression, caching, etc.

```
● Use Response Compression Middleware to compress responses.
```
```
● Use Response Caching Middleware to cache GET responses.
```
```
● Middleware can be composed for layered processing.
```
## 146. Response caching, output caching

```
● Response caching caches HTTP responses based on headers.
```
```
● Output caching (new in ASP.NET Core 7) caches entire output of endpoints.
```
## 147. Distributed caching / session state

```
● Use Redis or SQL Server for distributed cache/session in multi-server environments.
```
```
● Helps maintain session state without sticky sessions.
```

# https://www.linkedin.com/in/sandeeppal

## 148. SignalR (real-time communication)

```
● Enables real-time bi-directional communication.
```
```
● Supports WebSockets, Server-Sent Events, long polling.
```
## 149. Background tasks / hosted services

```
● Use IHostedService or BackgroundService to run background tasks.
```
```
● Useful for timers, queue processing.
```
## 150. Working with files and streaming

```
● Stream large files efficiently using FileStreamResult.
```
```
● Use async IO to avoid blocking.
```
## 151. Version of .NET Core / .NET changes (what’s new in latest)

```
● Track latest improvements like minimal APIs, source generators, performance
boosts.
```
```
● Keep updated with latest SDKs.
```
## Scenario / Design & Best Practices

## 152. How to structure a large ASP.NET Core solution (layers, clean

## architecture, onion architecture)


# https://www.linkedin.com/in/sandeeppal

```
● Use layered architecture: Presentation (API/UI), Application (services, business
logic), Domain (entities, business rules), Infrastructure (data access, external
services).
```
```
● Clean Architecture emphasizes separation of concerns and dependency direction
towards the domain layer.
```
```
● Onion Architecture structures the app around the core domain, with dependencies
pointing inward.
```
```
● Use projects to separate concerns and improve maintainability.
```
## 153. Dependency inversion, SOLID principles in ASP.NET Core

```
● Apply Dependency Inversion Principle by coding against abstractions (interfaces),
not implementations.
```
```
● Follow SOLID principles:
```
```
○ Single Responsibility: Each class has one reason to change.
```
```
○ Open/Closed: Classes open for extension, closed for modification.
```
```
○ Liskov Substitution: Subtypes can replace base types.
```
```
○ Interface Segregation: Use multiple specific interfaces.
```
```
○ Dependency Inversion: Depend on abstractions.
```
## 154. Handling resource cleanup (e.g. DbContext disposal)

```
● Use DI to manage lifecycle of DbContext as Scoped.
```
```
● Avoid manual disposal; rely on DI container.
```

# https://www.linkedin.com/in/sandeeppal

```
● Dispose IDisposable objects promptly when created manually.
```
```
● Use using statements for short-lived resources.
```
## 155. Design for testability (unit tests, integration tests)

```
● Write loosely coupled code via DI.
```
```
● Mock external dependencies for unit tests.
```
```
● Use in-memory databases (e.g., InMemory EF Core) for integration tests.
```
```
● Isolate layers to enable focused testing.
```
## 156. Logging vs tracing vs exception reporting

```
● Logging: recording app events/info.
```
```
● Tracing: tracking execution flow across components or services.
```
```
● Exception reporting: capturing and notifying on errors.
```
```
● Use structured logging and distributed tracing for diagnostics.
```
## 157. Data access: EF Core best practices (no tracking, lazy loading,

## migrations)

```
● Use No Tracking queries for read-only data to improve performance.
```
```
● Use lazy loading cautiously; prefer explicit loading to avoid surprises.
```
```
● Manage migrations with proper version control.
```

# https://www.linkedin.com/in/sandeeppal

```
● Use async queries to avoid blocking.
```
## 158. Handling database migrations in production safely

```
● Apply migrations in CI/CD pipeline with proper backups.
```
```
● Use transactional migrations where supported.
```
```
● Run migrations during maintenance windows.
```
```
● Test migrations in staging before production.
```
## 159. Versioning and backward compatibility of APIs

```
● Maintain multiple API versions with clear deprecation policies.
```
```
● Avoid breaking changes; use additive changes.
```
```
● Communicate version lifecycle clearly to consumers.
```
## 160. Rate limiting / throttling strategies

```
● Protect APIs from abuse using rate limits (requests per second/minute).
```
```
● Use libraries like AspNetCoreRateLimit or API Gateway features.
```
```
● Implement IP-based or user-based throttling.
```
## 161. Error / exception handling patterns


# https://www.linkedin.com/in/sandeeppal

```
● Use global exception handling middleware.
```
```
● Return meaningful HTTP status codes and error details.
```
```
● Avoid leaking sensitive info.
```
```
● Implement retry policies for transient errors.
```
## 162. Graceful shutdown

```
● Handle shutdown signals to complete ongoing requests.
```
```
● Dispose resources correctly.
```
```
● Use IHostApplicationLifetime events to hook into shutdown process.
```
## 163. Handling secrets securely

```
● Use Azure Key Vault , AWS Secrets Manager , or HashiCorp Vault.
```
```
● Avoid storing secrets in code or config files.
```
```
● Use environment variables or user secrets during development.
```
## 164. Use of configuration and environment variables in CI/CD

```
● Inject config via environment variables or secret stores in pipelines.
```
```
● Use multiple config files per environment (appsettings.Development.json).
```
```
● Secure sensitive values using CI/CD secret management.
```

# https://www.linkedin.com/in/sandeeppal

## 165. Internationalization / localization

```
● Use resource files (.resx) for strings.
```
```
● Configure RequestLocalizationMiddleware.
```
```
● Support multiple cultures and fallback cultures.
```
```
● Localize data formats, dates, currencies.
```
## 166. Validation of inputs to avoid security vulnerabilities (e.g. SQL

## injection, XSS etc)

```
● Use parameterized queries / ORM to prevent SQL injection.
```
```
● Sanitize and encode user input to prevent XSS.
```
```
● Validate inputs rigorously on server side.
```
```
● Use built-in validation attributes and custom validators.
```
## Sample / Misc Interview Questions

## 167. What is the difference between IActionResult and ActionResult<T>?

```
● IActionResult : Represents a non-generic result of an action method. Can return any
HTTP response (Ok, NotFound, Redirect, etc.).
```
```
● ActionResult<T> : Combines a result with a typed value (T). It allows returning typed
data or an HTTP response. Improves clarity and enables better OpenAPI docs.
```

# https://www.linkedin.com/in/sandeeppal

## 168. What is the role of Startup class now with newer versions of .NET

## vs minimal hosting model?

```
● In .NET 5 and earlier , Startup configures services and middleware.
```
```
● In .NET 6+ minimal hosting model , the Program.cs file combines service
registration and middleware setup with a simplified, top-level statement style.
```
```
● Startup can still be used for organization, but not required.
```
## 169. How to migrate an ASP.NET Core application from .NET 5 to .NET 8

## (or newer)?

```
● Update target framework in project file (net8.0).
```
```
● Update NuGet packages and dependencies.
```
```
● Adapt code for minimal APIs if desired.
```
```
● Replace Startup with minimal hosting model if preferred.
```
```
● Test thoroughly for API changes or obsoleted APIs.
```
```
● Review and update middleware and routing patterns.
```
## 170. What is minimal API and how is it different from controllers?

```
● Minimal APIs are lightweight endpoints defined with top-level statements, no
controller classes.
```
```
● Ideal for microservices or simple APIs.
```
```
● Less ceremony and fewer files.
```

# https://www.linkedin.com/in/sandeeppal

```
● Controllers provide richer features (filters, model binding, action results).
```
## 171. How do you handle version conflicts (e.g., multiple dependencies

## needing different versions of a library)?

```
● Use binding redirects (in .NET Framework).
```
```
● Use assembly version unification and strong-named assemblies.
```
```
● In .NET Core, resolve via NuGet package management , use central package
versions.
```
```
● Consider upgrading or consolidating dependencies.
```
## 172. What is endpoint routing?

```
● Introduced in ASP.NET Core 3.0.
```
```
● Centralized routing system that decouples route matching from middleware.
```
```
● Routes requests to endpoints defined by controllers, Razor Pages, minimal APIs.
```
```
● Supports route-based middleware filters.
```
## 173. Difference between conventional routing and attribute routing

```
● Conventional routing : Routes defined centrally (usually in Startup), patterns
applied globally.
```
```
● Attribute routing : Routes declared directly on controllers/actions via attributes
([Route], [HttpGet]).
```

# https://www.linkedin.com/in/sandeeppal

```
● Attribute routing is more flexible and explicit.
```
## 174. How to enable OpenAPI / Swagger UI and customizing it

```
● Add Swashbuckle.AspNetCore NuGet package.
```
```
● Configure Swagger services (builder.Services.AddSwaggerGen()).
```
```
● Enable middleware (app.UseSwagger(), app.UseSwaggerUI()).
```
```
● Customize with options like API info, document filters, UI themes.
```
## 175. What is content negotiation, how ASP.NET Core chooses media

## types

```
● Automatically selects response format (JSON, XML) based on Accept header.
```
```
● Configured via formatters in MVC options.
```
```
● Falls back to default formatter if no match.
```
## 176. What is ProblemDetails in WebAPI

```
● Standardized error response format defined by RFC 7807.
```
```
● Contains properties like status, title, detail, instance.
```
```
● Used by default in ASP.NET Core for error responses.
```

# https://www.linkedin.com/in/sandeeppal

## 177. How to return custom error responses / use custom middleware for

## error responses

```
● Implement custom exception handling middleware.
```
```
● Catch exceptions, set HTTP status, and return custom JSON payload.
```
```
● Use UseExceptionHandler() or global filters.
```
```
● Customize ProblemDetails or your own error models.
```
## 178. Using cancellation tokens in API controllers or actions

```
● Accept CancellationToken parameter in action methods.
```
```
● Pass token to async calls to support request cancellation.
```
```
● Improves responsiveness and resource management.
```
## 179. What are the default limits for file upload sizes, and how to

## configure them

```
● Default max request body size is 30 MB.
```
```
● Configure via RequestSizeLimit attribute or
KestrelServerOptions.Limits.MaxRequestBodySize.
```
```
● For IIS, adjust maxAllowedContentLength.
```
## 180. How to enable gzip or brotli compression


# https://www.linkedin.com/in/sandeeppal

```
● Add ResponseCompression middleware.
```
```
● Register compression providers (AddResponseCompression()) in Program.cs.
```
```
● Configure supported MIME types and compression level.
```
## 181. Working with JSON options: System.Text.Json vs Newtonsoft.Json

```
● System.Text.Json : Default in .NET Core 3+, fast, built-in, less feature-rich.
```
```
● Newtonsoft.Json : More mature, supports advanced scenarios (e.g., polymorphic
deserialization).
```
```
● Can switch to Newtonsoft by adding AddNewtonsoftJson() in MVC options.
```

