




## Configuration & AppSettings

## 86. Role of appsettings.json, appsettings.Development.json, etc.

```
‚óè appsettings.json: Base configuration file used across all environments.
```
```
‚óè appsettings.{Environment}.json: Environment-specific overrides (e.g.,
Development, Production).
```
üîß ASP.NET Core loads them automatically based on the environment:


# https://www.linkedin.com/in/sandeeppal

ASPNETCORE_ENVIRONMENT=Development

‚úÖ Loaded in order of precedence, where later files override earlier ones.

## 87. Environment-based configuration (Development, Staging,

## Production)

ASP.NET Core uses the ASPNETCORE_ENVIRONMENT variable to determine the runtime
environment.

Supported environments (by convention):

```
‚óè Development
```
```
‚óè Staging
```
```
‚óè Production
```
Environment-specific logic can be applied:

if (env.IsDevelopment()) { ... }

Also used to load:

```
‚óè appsettings.{env}.json
```
```
‚óè Startup{env}.cs (in older versions)
```
## 88. Overriding settings via environment variables, command line

‚úÖ ASP.NET Core supports **hierarchical override** of config sources:

```
‚óè Environment variables override appsettings.json:
```

# https://www.linkedin.com/in/sandeeppal

MyApp__Logging__LogLevel__Default=Warning

```
‚óè Command line arguments override everything:
```
dotnet run --Logging:LogLevel:Default=Debug

## 89. Using IConfiguration to read settings

Inject IConfiguration anywhere:

public class MyService {
private readonly string _apiKey;
public MyService(IConfiguration config) {
_apiKey = config["MySettings:ApiKey"];
}
}

You can also access nested settings via config.GetSection("MySettings").

## 90. Binding configuration sections to POCOs

Bind config to strongly typed objects:

public class MySettings {
public string ApiKey { get; set; }
public int Timeout { get; set; }
}

services.Configure<MySettings>(config.GetSection("MySettings"));

Use via IOptions<MySettings>.


# https://www.linkedin.com/in/sandeeppal

## 91. Using Options pattern (IOptions<T>, IOptionsSnapshot<T>,

## IOptionsMonitor<T>)

```
‚óè IOptions<T>: Reads settings once at startup.
```
```
‚óè IOptionsSnapshot<T>: Gets updated settings per request (for scoped services).
```
```
‚óè IOptionsMonitor<T>: Supports change notifications and works in singleton
services.
```
public MyService(IOptions<MySettings> options) {
var settings = options.Value;
}

## 92. Secret management (e.g. user secrets, Azure Key Vault)

```
‚óè User Secrets (for local dev):
```
dotnet user-secrets init
dotnet user-secrets set "MySettings:ApiKey" "secret"

```
‚óè Azure Key Vault :
```
builder.Configuration.AddAzureKeyVault(...);

‚úÖ Secure sensitive data like API keys, connection strings, tokens.

## 93. Logging configuration: how to configure log levels

In appsettings.json:

"Logging": {


# https://www.linkedin.com/in/sandeeppal

"LogLevel": {
"Default": "Information",
"Microsoft": "Warning",
"Microsoft.Hosting.Lifetime": "Information"
}
}

Supports built-in providers: Console, Debug, EventSource, Azure, etc.

Custom configuration through ILogger<T>.

## 94. Connection strings management

Stored under "ConnectionStrings" section in appsettings.json:

"ConnectionStrings": {
"DefaultConnection":
"Server=.;Database=AppDb;Trusted_Connection=True;"
}

Read via:

var conn = config.GetConnectionString("DefaultConnection");

Or inject via Options pattern.

## 95. Settings reloading (on change) if supported

JSON files support live reload:

builder.Configuration.AddJsonFile("appsettings.json", optional:
false, reloadOnChange: true);


# https://www.linkedin.com/in/sandeeppal

IOptionsMonitor<T> automatically updates bound values when config changes.

üîÅ **Does not work with all sources** (e.g., env vars, command line).

## 96. Strongly typed configuration

Using POCOs and Options pattern allows **type-safe config** :

services.Configure<MySettings>(config.GetSection("MySettings"));

Use [Required], [Range], etc., to add validation.

## 97. Validating configuration (e.g., using IValidateOptions)

You can validate bound config using IValidateOptions<T>:

public class MySettingsValidator : IValidateOptions<MySettings> {
public ValidateOptionsResult Validate(string name, MySettings
options) {
if (string.IsNullOrWhiteSpace(options.ApiKey)) {
return ValidateOptionsResult.Fail("ApiKey is
required.");
}
return ValidateOptionsResult.Success;
}
}

Register with DI:

services.AddSingleton<IValidateOptions<MySettings>,
MySettingsValidator>();

## 98. Configuration providers (JSON, XML, INI, Environment, Azure, etc.)


# https://www.linkedin.com/in/sandeeppal

ASP.NET Core supports multiple configuration providers:

```
‚óè JSON (default)
```
```
‚óè Environment Variables
```
```
‚óè Command Line Args
```
```
‚óè INI files
```
```
‚óè XML files
```
```
‚óè In-memory
```
```
‚óè Azure App Configuration
```
```
‚óè Azure Key Vault
```
```
‚óè Secrets Manager
```
Each can be chained with priority.

## 99. Default values and optional settings

Use default values in POCOs or fallback logic:

public class MySettings {
public string ApiKey { get; set; } = "default-api-key";
}

Or:

var apiKey = config["MySettings:ApiKey"] ?? "fallback";

## 100. Masking sensitive configuration data


# https://www.linkedin.com/in/sandeeppal

‚úÖ Best practices:

```
‚óè Don't log sensitive values
```
```
‚óè Use [JsonIgnore] or remove values before logging
```
```
‚óè Mask in logs manually:
```
_logger.LogInformation("Token: {Token}", Mask(token));

```
‚óè Never store secrets in source-controlled files (appsettings.json)
```
```
‚óè Use user-secrets , Key Vault , or environment variables instead
```


## Authentication & Authorization

## (JWT, Identity)

## 101. What is authentication vs authorization?

```
‚óè Authentication : Verifying the identity of a user (Who are you?)
```
```
‚óè Authorization : Determining if the authenticated user has permission to perform an
action (What are you allowed to do?)
```
In ASP.NET Core, both are handled via middleware and attributes like [Authorize], roles,
and policies.

## 102. How to configure ASP.NET Core Identity


# https://www.linkedin.com/in/sandeeppal

ASP.NET Core Identity provides a complete solution for:

```
‚óè User registration & login
```
```
‚óè Roles, claims, tokens
```
```
‚óè Password hashing
```
```
‚óè Two-factor authentication
```
‚úÖ Setup:

dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore

In Startup or Program.cs:

services.AddIdentity<IdentityUser, IdentityRole>()
.AddEntityFrameworkStores<ApplicationDbContext>()
.AddDefaultTokenProviders();

## 103. JWT Bearer tokens: what it is, how to configure

**JWT (JSON Web Token)** is a compact, URL-safe token format used for authentication.

‚úÖ Configure JWT auth:

services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
.AddJwtBearer(options => {
options.TokenValidationParameters = new
TokenValidationParameters {
ValidateIssuer = true,
ValidateAudience = true,
ValidateLifetime = true,
ValidateIssuerSigningKey = true,
IssuerSigningKey = new
SymmetricSecurityKey(Encoding.UTF8.GetBytes("your-secret"))
};


# https://www.linkedin.com/in/sandeeppal

#### });

Use [Authorize] to secure endpoints.

## 104. Role-based vs policy-based authorization

‚úÖ **Role-based** :

[Authorize(Roles = "Admin")]

‚úÖ **Policy-based** :

services.AddAuthorization(options => {
options.AddPolicy("CanEdit", policy =>
policy.RequireClaim("EditPermission"));
});

Then use:

[Authorize(Policy = "CanEdit")]

Policy-based gives more flexibility (custom requirements, claims, logic).

## 105. Using Claims

Claims are user attributes (e.g., email, role, permissions).

Add claims when creating identity:

var claims = new List<Claim> {
new Claim(ClaimTypes.Name, user.UserName),
new Claim("Permission", "Edit")
};


# https://www.linkedin.com/in/sandeeppal

Access in code:

var claim = User.FindFirst("Permission")?.Value;

## 106. Cookie-based authentication

Used in traditional MVC apps for session-based auth.

services.AddAuthentication(CookieAuthenticationDefaults.Authenticati
onScheme)
.AddCookie(options => {
options.LoginPath = "/Account/Login";
});

On login:

await HttpContext.SignInAsync(principal);

Cookies are stored in the browser and sent with each request.

## 107. External logins (OAuth, OpenID Connect)

Use built-in providers:

services.AddAuthentication()
.AddGoogle(options => {
options.ClientId = "...";
options.ClientSecret = "...";
});

Also supports:

```
‚óè Facebook
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Microsoft
```
```
‚óè Twitter
```
```
‚óè OpenID Connect
```
```
‚óè Azure AD
```
Use RemoteAuthenticationHandler<T> or Identity scaffolding.

## 108. Refresh tokens

Used with **JWT** to renew access tokens after expiration without logging in again.

```
‚óè Issue refresh token along with access token.
```
```
‚óè Store securely (DB or secure HTTP-only cookie).
```
```
‚óè On access token expiration, send refresh token to get a new one.
```
You must manually implement refresh token logic (not built-in to Identity).

## 109. Token expiration, token revocation

```
‚óè JWTs typically expire in 5‚Äì30 minutes.
```
```
‚óè Expired tokens cannot be used.
```
```
‚óè Revocation requires token blacklisting (e.g., database of revoked tokens).
```
‚úÖ Configure expiration:

Expires = DateTime.UtcNow.AddMinutes(30)

‚úÖ Use refresh tokens to handle expiration.


# https://www.linkedin.com/in/sandeeppal

## 110. Securing routes with [Authorize] and [AllowAnonymous]

```
‚óè [Authorize]: Requires authenticated user
```
```
‚óè [Authorize(Roles = "Admin")]: Requires role
```
```
‚óè [AllowAnonymous]: Allows access without login
```
Example:

[Authorize]
public IActionResult Dashboard() { }

[AllowAnonymous]
public IActionResult Login() { }

## 111. Custom authorization policies and handlers

Define complex authorization rules using **IAuthorizationHandler** :

public class MinimumAgeRequirement : IAuthorizationRequirement {
public int Age { get; }
public MinimumAgeRequirement(int age) => Age = age;
}

public class MinimumAgeHandler :
AuthorizationHandler<MinimumAgeRequirement> {
protected override Task HandleRequirementAsync(...) {
// logic
}
}

Register in DI and use with [Authorize(Policy = "...")].


# https://www.linkedin.com/in/sandeeppal

## 112. Data protection (for cookies, tokens)

ASP.NET Core uses **Data Protection API** to:

```
‚óè Encrypt authentication cookies
```
```
‚óè Protect tokens (e.g., password reset tokens)
```
Configure:

services.AddDataProtection()
.PersistKeysToFileSystem(new DirectoryInfo("path"))
.SetApplicationName("AppName");

Used internally by Identity and cookie middleware.

## 113. Multi-tenant auth scenarios

Multi-tenancy can involve:

```
‚óè Per-tenant databases
```
```
‚óè Per-tenant user stores
```
```
‚óè Per-tenant roles/policies
```
Strategies:

```
‚óè Use claims to store tenant ID
```
```
‚óè Filter data per tenant
```
```
‚óè Custom middleware for tenant resolution
```
Can integrate with IdentityServer4 or Azure AD B2C for federated auth.


# https://www.linkedin.com/in/sandeeppal

## 114. Securing password storage

ASP.NET Core Identity uses **PBKDF2** hashing by default.

Best practices:

```
‚óè Never store plaintext passwords
```
```
‚óè Use salted + hashed storage
```
```
‚óè Use PasswordHasher<T> or Identity defaults
```
Use:

PasswordHasher<T>.HashPassword(user, password)

Can switch to Argon2, Bcrypt via custom password hasher.

## 115. Two ‚Äê factor authentication (2FA)

Supported out of the box in ASP.NET Core Identity.

Options:

```
‚óè SMS (via provider)
```
```
‚óè Email
```
```
‚óè Authenticator app (TOTP)
```
Enable via Identity configuration:

services.Configure<IdentityOptions>(options => {
options.SignIn.RequireConfirmedEmail = true;
});


# https://www.linkedin.com/in/sandeeppal

Use SignInManager<T> to handle verification and token generation.

## Filters & Middleware Overlaps

## 116. What are filters in ASP.NET Core?

Filters are components that run code before or after certain stages in the request pipeline
within MVC or Razor Pages. Types of filters include:

```
‚óè Authorization filters: Run before any other filter to check user authorization.
```
```
‚óè Resource filters: Run after authorization and before model binding.
```
```
‚óè Action filters: Run before and after the execution of action methods.
```
```
‚óè Exception filters: Handle unhandled exceptions thrown by actions.
```
```
‚óè Result filters: Run before and after action results are executed.
```
Filters allow you to inject logic at these specific points.

## 117. How do filters differ from middleware?

```
‚óè Middleware is part of the global HTTP request pipeline and executes for every
request.
```
```
‚óè Filters only run within MVC/Razor pipeline, for controller actions or Razor Pages
handlers.
```
```
‚óè Middleware runs earlier and can short-circuit the entire pipeline; filters run later,
scoped to MVC processing.
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Middleware is good for cross-cutting concerns affecting all requests, filters are better
for concerns around controller/action execution.
```
## 118. What is the order of filters?

Filters run in a specific order depending on their type:

```
‚óè Authorization filters run first.
```
```
‚óè Resource filters run next.
```
```
‚óè Model binding happens after resource filters.
```
```
‚óè Action filters run around the action execution.
```
```
‚óè Exception filters handle exceptions thrown during action or result execution.
```
```
‚óè Result filters run around result execution.
```
Within each type, filters can be ordered by their Order property and whether they are global,
controller-level, or action-level.

## 119. How to create and use custom filters?

Create a custom filter by implementing one of the filter interfaces like:

public class CustomActionFilter : IActionFilter
{
public void OnActionExecuting(ActionExecutingContext context)
{
// Before action executes
}
public void OnActionExecuted(ActionExecutedContext context)
{
// After action executes


# https://www.linkedin.com/in/sandeeppal

#### }

#### }

Register globally in Startup:

services.AddControllersWithViews(options =>
{
options.Filters.Add<CustomActionFilter>();
});

Or decorate controllers/actions:

[ServiceFilter(typeof(CustomActionFilter))]
public class HomeController : Controller { ... }

## 120. Global filters vs per-controller/action filters

```
‚óè Global filters apply to all MVC actions, registered via AddControllers or AddMvc
options.
```
```
‚óè Controller or action filters are applied via attributes directly on controllers or
actions.
```
```
‚óè Global filters are best for cross-cutting concerns like logging, exception handling.
```
```
‚óè Controller/action filters are best for behavior specific to particular routes or endpoints.
```
## 121. What is filter context and what can filters do?

Filters receive context objects (e.g., ActionExecutingContext) providing:

```
‚óè HTTP context and request data.
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Access to action parameters.
```
```
‚óè Ability to modify or cancel execution (e.g., short-circuit).
```
```
‚óè Access to the result or exceptions.
```
```
‚óè Ability to set result or modify response.
```
This allows filters to inspect, modify, or block processing at their stage.

## 122. What is short-circuiting in filters?

Filters can **short-circuit** by setting the result early, preventing further execution:

public void OnActionExecuting(ActionExecutingContext context)
{
if (!IsAuthorized())
{
context.Result = new UnauthorizedResult(); // stops pipeline
here
}
}

This prevents action execution and later filters from running.

## 123. Filter attributes vs service-based filters

```
‚óè Filter attributes are instantiated per request and support parameters, but have
limited DI capabilities.
```
```
‚óè Service-based filters (using ServiceFilter or TypeFilter) allow filters to be
resolved from DI container, enabling constructor injection.
```
Use service-based filters when you need dependencies injected.


# https://www.linkedin.com/in/sandeeppal

## 124. Combining filters with middleware for cross-cutting concerns

```
‚óè Use middleware for concerns that affect all requests (logging, CORS,
authentication).
```
```
‚óè Use filters for MVC-specific concerns tied to action execution (authorization,
validation, caching).
```
```
‚óè Filters can complement middleware for granular control within MVC.
```
```
‚óè Example: Use middleware for global exception logging, filters for handling
MVC-specific exceptions and returning appropriate views or API responses.
```
## Versioning, CORS

## 125. Implementing API versioning

API versioning enables multiple versions of your API to coexist, allowing clients to migrate
gradually.

Common ways to version APIs in ASP.NET Core:

```
‚óè URL versioning (e.g., /api/v1/products)
```
```
‚óè Query string versioning (e.g., /api/products?api-version=1.0)
```
```
‚óè Header versioning (custom header like api-version: 1.0)
```
```
‚óè Media type versioning (via Accept header, e.g., application/json;v=1)
```
Use the Microsoft.AspNetCore.Mvc.Versioning NuGet package:

services.AddApiVersioning(options => {
options.AssumeDefaultVersionWhenUnspecified = true;


# https://www.linkedin.com/in/sandeeppal

options.DefaultApiVersion = new ApiVersion(1, 0);
options.ReportApiVersions = true;
});

## 126. Semantic versioning / version negotiation

Semantic versioning (semver) uses MAJOR.MINOR.PATCH format, e.g., 1.2.0.

```
‚óè MAJOR version changes break backward compatibility.
```
```
‚óè MINOR versions add functionality in a backward-compatible manner.
```
```
‚óè PATCH versions are for backward-compatible bug fixes.
```
Version negotiation allows clients and servers to agree on an API version via headers or
URL. Servers should support multiple versions and respond with supported version info.

## 127. Deprecation strategies

```
‚óè Mark old versions as deprecated via documentation and HTTP response headers.
```
```
‚óè Return warning headers or custom fields indicating version deprecation.
```
```
‚óè Gradually phase out old versions, allowing clients to migrate.
```
```
‚óè Consider introducing sunset policies and endpoints to notify clients.
```
## 128. CORS: What is it?

**CORS (Cross-Origin Resource Sharing)** is a browser security feature that restricts web
pages from making requests to a different domain than the one that served the web page, to
prevent cross-site attacks.


# https://www.linkedin.com/in/sandeeppal

CORS defines a way for servers to allow controlled access to resources from a different
origin.

## 129. How to set CORS policies in ASP.NET Core

Configure in Startup.cs or Program.cs:

services.AddCors(options =>
{
options.AddPolicy("AllowSpecificOrigin",
builder =>
{
builder.WithOrigins("https://example.com")
.AllowAnyHeader()
.AllowAnyMethod();
});
});

Enable middleware:

app.UseCors("AllowSpecificOrigin");

## 130. Preflight requests

```
‚óè For certain CORS requests (e.g., methods other than GET/POST or custom
headers), browsers send an OPTIONS request first, called a preflight.
```
```
‚óè The server must respond with allowed methods, headers, and origins.
```
```
‚óè Properly configured CORS policies handle preflight requests automatically.
```
## 131. Configuring CORS globally vs per endpoint


# https://www.linkedin.com/in/sandeeppal

```
‚óè Global CORS : Apply a policy for all endpoints by adding middleware early in the
pipeline with app.UseCors(...).
```
```
‚óè Per-endpoint CORS : Apply CORS policies selectively using the
[EnableCors("PolicyName")] or [DisableCors] attributes on controllers or
actions.
```
## 132. Handling cross-origin credentials

```
‚óè To allow cookies or credentials in cross-origin requests, configure:
```
builder.WithOrigins("https://example.com")
.AllowCredentials()
.AllowAnyHeader()
.AllowAnyMethod();

```
‚óè Clients must send requests with credentials: 'include'.
```
```
‚óè Note: Allowing credentials disables the wildcard (*) origin.
```
## 133. Security implications of CORS

```
‚óè Improperly configured CORS can expose your API to CSRF and data theft.
```
```
‚óè Avoid using AllowAnyOrigin with AllowCredentials as browsers block it.
```
```
‚óè Restrict origins to trusted domains.
```
```
‚óè Validate CORS headers and avoid overly permissive policies.
```
```
‚óè Use HTTPS to secure cross-origin requests.
```

# https://www.linkedin.com/in/sandeeppal

## Cross ‚Äë Cutting / Advanced / ‚ÄúMiscellaneous‚Äù

## 134. Hosting: Kestrel, IIS, reverse proxy scenarios

```
‚óè Kestrel is the default cross-platform web server for ASP.NET Core, lightweight and
fast.
```
```
‚óè IIS acts as a reverse proxy on Windows, forwarding requests to Kestrel.
```
```
‚óè Reverse proxies improve security, manage SSL, handle load balancing.
```
```
‚óè On Linux, Nginx or Apache often act as reverse proxies to Kestrel.
```
## 135. InProcess vs OutOfProcess hosting

```
‚óè InProcess hosting runs ASP.NET Core app inside the IIS worker process
(w3wp.exe), better performance.
```
```
‚óè OutOfProcess hosting runs the app in a separate process, IIS proxies requests to
it.
```
```
‚óè InProcess is default in ASP.NET Core 3.0+ for IIS hosting.
```
## 136. Health checks

```
‚óè Health checks provide endpoints to report app health.
```
```
‚óè Use Microsoft.AspNetCore.Diagnostics.HealthChecks.
```
```
‚óè Configure checks for databases, external services, dependencies.
```
```
‚óè Useful for Kubernetes, load balancers.
```

# https://www.linkedin.com/in/sandeeppal

## 137. Logging: built-in logging, third party (Serilog, NLog)

```
‚óè ASP.NET Core has built-in logging with providers (Console, Debug, EventSource).
```
```
‚óè Third-party libs like Serilog and NLog offer rich sinks, structured logging.
```
```
‚óè Configure logging via appsettings.json or code.
```
## 138. Performance tuning: caching (in memory, distributed), response

## compression

```
‚óè In-memory caching stores data on server memory for fast retrieval.
```
```
‚óè Distributed caching uses external stores (Redis, SQL) for multiple servers.
```
```
‚óè Response compression reduces payload size using gzip, Brotli middleware.
```
## 139. Threading concerns, concurrency, deadlocks

```
‚óè Avoid blocking calls in async code to prevent deadlocks.
```
```
‚óè Use async/await properly.
```
```
‚óè Protect shared data with locks or concurrent collections.
```
```
‚óè Avoid thread starvation with thread pool tuning.
```
## 140. Memory leaks, disposal of dependencies

```
‚óè Memory leaks can occur if IDisposable objects aren‚Äôt disposed.
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Use dependency injection lifetimes properly.
```
```
‚óè Be cautious with static references and events holding objects.
```
```
‚óè Use tools like dotMemory, PerfView.
```
## 141. Scalability: load balancing, statelessness

```
‚óè Design apps to be stateless so any server instance can handle requests.
```
```
‚óè Use distributed caches or external session stores.
```
```
‚óè Load balancers distribute traffic to multiple instances.
```
## 142. Deployment: Docker, Azure, CI/CD pipelines

```
‚óè Containerize apps with Docker for consistent deployments.
```
```
‚óè Use Azure App Services, Azure Kubernetes Service for cloud hosting.
```
```
‚óè Set up CI/CD pipelines (GitHub Actions, Azure DevOps) for automated builds and
deployments.
```
## 143. Monitoring, metrics, tracing (OpenTelemetry etc)

```
‚óè Monitor app health, request metrics, errors.
```
```
‚óè Use OpenTelemetry for distributed tracing.
```
```
‚óè Integrate with Application Insights, Prometheus, Grafana.
```

# https://www.linkedin.com/in/sandeeppal

## 144. Security best practices (HTTPS, XSS, CSRF, OWASP)

```
‚óè Enforce HTTPS.
```
```
‚óè Use Anti-forgery tokens to prevent CSRF.
```
```
‚óè Sanitize input to prevent XSS.
```
```
‚óè Follow OWASP guidelines to secure apps.
```
## 145. Middleware for compression, caching, etc.

```
‚óè Use Response Compression Middleware to compress responses.
```
```
‚óè Use Response Caching Middleware to cache GET responses.
```
```
‚óè Middleware can be composed for layered processing.
```
## 146. Response caching, output caching

```
‚óè Response caching caches HTTP responses based on headers.
```
```
‚óè Output caching (new in ASP.NET Core 7) caches entire output of endpoints.
```
## 147. Distributed caching / session state

```
‚óè Use Redis or SQL Server for distributed cache/session in multi-server environments.
```
```
‚óè Helps maintain session state without sticky sessions.
```

# https://www.linkedin.com/in/sandeeppal

## 148. SignalR (real-time communication)

```
‚óè Enables real-time bi-directional communication.
```
```
‚óè Supports WebSockets, Server-Sent Events, long polling.
```
## 149. Background tasks / hosted services

```
‚óè Use IHostedService or BackgroundService to run background tasks.
```
```
‚óè Useful for timers, queue processing.
```
## 150. Working with files and streaming

```
‚óè Stream large files efficiently using FileStreamResult.
```
```
‚óè Use async IO to avoid blocking.
```
## 151. Version of .NET Core / .NET changes (what‚Äôs new in latest)

```
‚óè Track latest improvements like minimal APIs, source generators, performance
boosts.
```
```
‚óè Keep updated with latest SDKs.
```
## Scenario / Design & Best Practices

## 152. How to structure a large ASP.NET Core solution (layers, clean

## architecture, onion architecture)


# https://www.linkedin.com/in/sandeeppal

```
‚óè Use layered architecture: Presentation (API/UI), Application (services, business
logic), Domain (entities, business rules), Infrastructure (data access, external
services).
```
```
‚óè Clean Architecture emphasizes separation of concerns and dependency direction
towards the domain layer.
```
```
‚óè Onion Architecture structures the app around the core domain, with dependencies
pointing inward.
```
```
‚óè Use projects to separate concerns and improve maintainability.
```
## 153. Dependency inversion, SOLID principles in ASP.NET Core

```
‚óè Apply Dependency Inversion Principle by coding against abstractions (interfaces),
not implementations.
```
```
‚óè Follow SOLID principles:
```
```
‚óã Single Responsibility: Each class has one reason to change.
```
```
‚óã Open/Closed: Classes open for extension, closed for modification.
```
```
‚óã Liskov Substitution: Subtypes can replace base types.
```
```
‚óã Interface Segregation: Use multiple specific interfaces.
```
```
‚óã Dependency Inversion: Depend on abstractions.
```
## 154. Handling resource cleanup (e.g. DbContext disposal)

```
‚óè Use DI to manage lifecycle of DbContext as Scoped.
```
```
‚óè Avoid manual disposal; rely on DI container.
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Dispose IDisposable objects promptly when created manually.
```
```
‚óè Use using statements for short-lived resources.
```
## 155. Design for testability (unit tests, integration tests)

```
‚óè Write loosely coupled code via DI.
```
```
‚óè Mock external dependencies for unit tests.
```
```
‚óè Use in-memory databases (e.g., InMemory EF Core) for integration tests.
```
```
‚óè Isolate layers to enable focused testing.
```
## 156. Logging vs tracing vs exception reporting

```
‚óè Logging: recording app events/info.
```
```
‚óè Tracing: tracking execution flow across components or services.
```
```
‚óè Exception reporting: capturing and notifying on errors.
```
```
‚óè Use structured logging and distributed tracing for diagnostics.
```
## 157. Data access: EF Core best practices (no tracking, lazy loading,

## migrations)

```
‚óè Use No Tracking queries for read-only data to improve performance.
```
```
‚óè Use lazy loading cautiously; prefer explicit loading to avoid surprises.
```
```
‚óè Manage migrations with proper version control.
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Use async queries to avoid blocking.
```
## 158. Handling database migrations in production safely

```
‚óè Apply migrations in CI/CD pipeline with proper backups.
```
```
‚óè Use transactional migrations where supported.
```
```
‚óè Run migrations during maintenance windows.
```
```
‚óè Test migrations in staging before production.
```
## 159. Versioning and backward compatibility of APIs

```
‚óè Maintain multiple API versions with clear deprecation policies.
```
```
‚óè Avoid breaking changes; use additive changes.
```
```
‚óè Communicate version lifecycle clearly to consumers.
```
## 160. Rate limiting / throttling strategies

```
‚óè Protect APIs from abuse using rate limits (requests per second/minute).
```
```
‚óè Use libraries like AspNetCoreRateLimit or API Gateway features.
```
```
‚óè Implement IP-based or user-based throttling.
```
## 161. Error / exception handling patterns


# https://www.linkedin.com/in/sandeeppal

```
‚óè Use global exception handling middleware.
```
```
‚óè Return meaningful HTTP status codes and error details.
```
```
‚óè Avoid leaking sensitive info.
```
```
‚óè Implement retry policies for transient errors.
```
## 162. Graceful shutdown

```
‚óè Handle shutdown signals to complete ongoing requests.
```
```
‚óè Dispose resources correctly.
```
```
‚óè Use IHostApplicationLifetime events to hook into shutdown process.
```
## 163. Handling secrets securely

```
‚óè Use Azure Key Vault , AWS Secrets Manager , or HashiCorp Vault.
```
```
‚óè Avoid storing secrets in code or config files.
```
```
‚óè Use environment variables or user secrets during development.
```
## 164. Use of configuration and environment variables in CI/CD

```
‚óè Inject config via environment variables or secret stores in pipelines.
```
```
‚óè Use multiple config files per environment (appsettings.Development.json).
```
```
‚óè Secure sensitive values using CI/CD secret management.
```

# https://www.linkedin.com/in/sandeeppal

## 165. Internationalization / localization

```
‚óè Use resource files (.resx) for strings.
```
```
‚óè Configure RequestLocalizationMiddleware.
```
```
‚óè Support multiple cultures and fallback cultures.
```
```
‚óè Localize data formats, dates, currencies.
```
## 166. Validation of inputs to avoid security vulnerabilities (e.g. SQL

## injection, XSS etc)

```
‚óè Use parameterized queries / ORM to prevent SQL injection.
```
```
‚óè Sanitize and encode user input to prevent XSS.
```
```
‚óè Validate inputs rigorously on server side.
```
```
‚óè Use built-in validation attributes and custom validators.
```
## Sample / Misc Interview Questions

## 167. What is the difference between IActionResult and ActionResult<T>?

```
‚óè IActionResult : Represents a non-generic result of an action method. Can return any
HTTP response (Ok, NotFound, Redirect, etc.).
```
```
‚óè ActionResult<T> : Combines a result with a typed value (T). It allows returning typed
data or an HTTP response. Improves clarity and enables better OpenAPI docs.
```

# https://www.linkedin.com/in/sandeeppal

## 168. What is the role of Startup class now with newer versions of .NET

## vs minimal hosting model?

```
‚óè In .NET 5 and earlier , Startup configures services and middleware.
```
```
‚óè In .NET 6+ minimal hosting model , the Program.cs file combines service
registration and middleware setup with a simplified, top-level statement style.
```
```
‚óè Startup can still be used for organization, but not required.
```
## 169. How to migrate an ASP.NET Core application from .NET 5 to .NET 8

## (or newer)?

```
‚óè Update target framework in project file (net8.0).
```
```
‚óè Update NuGet packages and dependencies.
```
```
‚óè Adapt code for minimal APIs if desired.
```
```
‚óè Replace Startup with minimal hosting model if preferred.
```
```
‚óè Test thoroughly for API changes or obsoleted APIs.
```
```
‚óè Review and update middleware and routing patterns.
```
## 170. What is minimal API and how is it different from controllers?

```
‚óè Minimal APIs are lightweight endpoints defined with top-level statements, no
controller classes.
```
```
‚óè Ideal for microservices or simple APIs.
```
```
‚óè Less ceremony and fewer files.
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Controllers provide richer features (filters, model binding, action results).
```
## 171. How do you handle version conflicts (e.g., multiple dependencies

## needing different versions of a library)?

```
‚óè Use binding redirects (in .NET Framework).
```
```
‚óè Use assembly version unification and strong-named assemblies.
```
```
‚óè In .NET Core, resolve via NuGet package management , use central package
versions.
```
```
‚óè Consider upgrading or consolidating dependencies.
```
## 172. What is endpoint routing?

```
‚óè Introduced in ASP.NET Core 3.0.
```
```
‚óè Centralized routing system that decouples route matching from middleware.
```
```
‚óè Routes requests to endpoints defined by controllers, Razor Pages, minimal APIs.
```
```
‚óè Supports route-based middleware filters.
```
## 173. Difference between conventional routing and attribute routing

```
‚óè Conventional routing : Routes defined centrally (usually in Startup), patterns
applied globally.
```
```
‚óè Attribute routing : Routes declared directly on controllers/actions via attributes
([Route], [HttpGet]).
```

# https://www.linkedin.com/in/sandeeppal

```
‚óè Attribute routing is more flexible and explicit.
```
## 174. How to enable OpenAPI / Swagger UI and customizing it

```
‚óè Add Swashbuckle.AspNetCore NuGet package.
```
```
‚óè Configure Swagger services (builder.Services.AddSwaggerGen()).
```
```
‚óè Enable middleware (app.UseSwagger(), app.UseSwaggerUI()).
```
```
‚óè Customize with options like API info, document filters, UI themes.
```
## 175. What is content negotiation, how ASP.NET Core chooses media

## types

```
‚óè Automatically selects response format (JSON, XML) based on Accept header.
```
```
‚óè Configured via formatters in MVC options.
```
```
‚óè Falls back to default formatter if no match.
```
## 176. What is ProblemDetails in WebAPI

```
‚óè Standardized error response format defined by RFC 7807.
```
```
‚óè Contains properties like status, title, detail, instance.
```
```
‚óè Used by default in ASP.NET Core for error responses.
```

# https://www.linkedin.com/in/sandeeppal

## 177. How to return custom error responses / use custom middleware for

## error responses

```
‚óè Implement custom exception handling middleware.
```
```
‚óè Catch exceptions, set HTTP status, and return custom JSON payload.
```
```
‚óè Use UseExceptionHandler() or global filters.
```
```
‚óè Customize ProblemDetails or your own error models.
```
## 178. Using cancellation tokens in API controllers or actions

```
‚óè Accept CancellationToken parameter in action methods.
```
```
‚óè Pass token to async calls to support request cancellation.
```
```
‚óè Improves responsiveness and resource management.
```
## 179. What are the default limits for file upload sizes, and how to

## configure them

```
‚óè Default max request body size is 30 MB.
```
```
‚óè Configure via RequestSizeLimit attribute or
KestrelServerOptions.Limits.MaxRequestBodySize.
```
```
‚óè For IIS, adjust maxAllowedContentLength.
```
## 180. How to enable gzip or brotli compression


# https://www.linkedin.com/in/sandeeppal

```
‚óè Add ResponseCompression middleware.
```
```
‚óè Register compression providers (AddResponseCompression()) in Program.cs.
```
```
‚óè Configure supported MIME types and compression level.
```
## 181. Working with JSON options: System.Text.Json vs Newtonsoft.Json

```
‚óè System.Text.Json : Default in .NET Core 3+, fast, built-in, less feature-rich.
```
```
‚óè Newtonsoft.Json : More mature, supports advanced scenarios (e.g., polymorphic
deserialization).
```
```
‚óè Can switch to Newtonsoft by adding AddNewtonsoftJson() in MVC options.
```

